^title Пул объектов
^section Низкоуровневая оптимизация

## Общая мысль

*Улучшить быстродействие и оптимизировать работу с памятью путем переиспользования объектов из пула фиксированного размера вместо того, чтобы каждый раз создавать и уничтожать объект.*

## Предыстория

Мы работаем над визуальными эффектами для нашей игры. Когда герой наносит заклинание, сноп искр должен рассыпаться по экрану. Это задача для *системы частиц*: движок, который выпускает маленькие картинки искр и передвигает их, пока они не потухнут.

Поскольку одиночный взмах волшебной палочки может вызвать сотни искр, наша система должна быть способна очень быстро создавать и уничтожать эти частицы и при этом не вызывать дефрагментацию памяти.

### Фрагментация -- это плохо

Программирование для консолей, таких как XBox 360, больше похоже на программирование для встроенных устройств, чем на программирование для обычных компьютеров. Игры для консолей обязаны долгое время работать без сбоев и утечек памяти, а эффективные менеджеры памяти редко попадаются на пути. В этом случае фрагментация памяти -- смерти подобно.

Фрагментация означает, что свободное место в куче <span name="park">разбивается</span> на маленькие кусочки памяти, вместо одного большого свободного блока. *Общий*  объем свободной памяти может быть большой, но самый большой *непрерывный* регион может быть ужасно маленьким. Например, может быть 14 байтов свободно, но они состоят из двух 7-байтных кусков с большим разрывом между собой. Если мы захотим выделить 12 байт, то потерпим неудачу. И все, никаких звездочек больше на экране.

<aside name="park">

Это как парковаться на улице, где уже есть куча припаркованных автомобилей. Если бы их сдвинуть вплотную, то место быстро бы нашлось. Но машины стоят слишком широко, и втиснуться просто некуда.

</aside>

<span name="heap"></span>

<img src="images/object-pool-heap-fragment.png" />

<aside name="heap">

Тут объясняется, как память становиться фрагментированной, и как можно потерпеть неудачу, пытаясь разместить объект, для которого, вроде бы, хватает места.

</aside>

Даже если фрагментация несильная, она все равно может <span name="soak">постепенно</span> превратить память в бесполезный кусок сыра с открытыми дырками, что повредит всей игре.

<aside name="soak">

Разработчики для консолей проводят тесты, в которых они оставляют игру запущенной на несколько дней. Если игра падает, то её просто не выпускают. Хотя игра может упасть из-за редко воспроизводящегося бага, чаще всего именно чрезмерная фрагментация или утечка памяти приводят к сбою.

</aside>

### Берем лучшее от всех

Из-за фрагментации, и ещё потому что выделение памяти может быть медленной, игры заботяться о том как и когда они управляют памятью. Простое решение обычно лучше: просто выделяем себе сразу большой кусок памяти, когда игра запускается и не отпускаем его, пока она не закончится. Но это не подходит для систем, где бы должны выделять и освобождать память во время игры.

Пул объектов позволяет пользоваться плюсами обоих подходов: со стороны менеджера памяти мы выделяем один большой кусок памяти и не отпускаем, пока игра идет. А для пользователей пула объектов мы будем прозрачно создавать и уничтожать объекты.

## Принцип работы

Есть **класс пула**, который содержит коллекцию **используемых объектов**. У каждый объекта есть **статус**, который говорит нам, занят ли этот объект. Когда пул инициализируется, он создает коллекцию объектов заранее и ставит им все статус "свободен".

Когда вам нужен новый объект, вы просите пул отдать его вам. Он находит свободный объект, ставит ему статус "занят" и возвращает вам. Если объект больше не нужен, ему опять ставится статус "свободен". Таким образом, объекты могут быть заняты и освобождены без реального выделения памяти или других ресурсов.

## Когда это использовать

Этот паттерн часто используется в играх не только для визуальных эффектов и игровых объектов, но и для невидимых структур, таких как звуки. Используйте пул, если:

*   Нужно часто создавать и уничтожать объекты.

*   Все объекты одинакового размера.

*   Выделение памяти для объекта происходит медленно или может привести к фрагментации памяти.

*   Каждый объект содержит в себе доступ к ресурсу, например соединение с базой данных или сетью, который медленно открывается и может быть переиспользован.

## Что нужно помнить

Обычно можно положиться на сборщик мусора или использовать `malloc()` и `free()` для работы с памятью. Но с помощью пула объектов, вы как бы говорите, что "я знаю лучше, как эта память должна быть использована". Это значит, что вы сами будете решать все проблемы.

### Можно потерять память на объектах, которые не используются

Размер пула объектов зависит от нужд игры. При настройке, обычно очевидны ситуации, когда пул *слишком* мал (падение привлекает внимание, как ничто другое). Но лучше ещё и убедиться, что пул не *слишком большой*. Маленький пул освободит память, которую можно использовать для других прикольных штук.

### Ограничено количество объектов, которые можно одновременно активировать

По-своему, это хорошее свойство. Разбивка памяти на отдельные пулы для разных типов объектов помогает, например при массовых взрывах на экране, не съесть *всю* доступную память. Что может привести к критической проблеме, например, не получиться создать нового врага.

Тем не менее, это означает, что нужно быть готовым к ситуации, когда не удасться получить объект из пула, потому что все они заняты. Есть несколько стратегий для этой ситуации.

1.  *Заранее избежать этого.* Часто используемое "решение": настроить размер пула так, что он никогда не переполнится, неважно как пойдет игра. Для пулов с важными вещами, как враги и объекты инвентаря, это разумное решение чаще всего. Тяжело придумать, как решить проблему нехватки объекта, когда нужно создать супербосса для игрока в конце уровня. Так что лучше просто убедиться, что такого не произойдет.
    
    Минус этого решения в том, что вы, как собака на сене, будете сидеть на объектах, которые будут нужны только пару редких раз. Из-за этого пулы фиксированных размеров не всегда подходят. Например, на некоторых уровнях могут быть широко использованы визуальных эффекты, а на других -- звуковые. В каждом случае тип и размер пула придется выбирать.

2.  *Просто не создавать объект.* Звучит странно, но это имеет смысл для вещей типа системы частиц. Если все частицы используются, то экран скорее всего наполнен вспыхивающей графикой. Игрок не заметит, если следующий взрыв будет не таким мощным, как предыдущий.

3.  *Освободить занятый объект.* Допустим, есть пул звуков, и вы хотите проиграть новый звук, хотя пул заполнен. И вы *не хотите*, чтобы игрок пропустил новый звук: легко заметить, если автомат не стреляет иногда. Тогда лучшим решением будет найти самый тихий звук, который сейчас проигрывается и заменить его новым. Новый звук замаскирует пропажу старого.

    В общем, если *пропажа* существующего объекта будет менее заметной, чем *отсутствие* нового, это может оказаться верным направлением.

4.  *Увеличить размер пула.* Если ваша игра может позволить себе гибкость с памятью, то можно увеличить размер пула прямо во время работы, или создать второй, вспомогательный пул. Если при этом будет использоваться слишком много памяти, можно добавить функцию уменьшения размера пула, когда дополнительная емкость больше не нужна.

### Для каждого объекта выделяется фиксированный размер памяти

Большинство реализаций пула хранят объекты в простом массиве. Если все объекты одного типа, то это нормально. Но если типы объектов могут быть разные, или дочерний класс объекта добавляет себе поля, нужно учитывать это при выделении памяти для пула. Нужно убедиться, что пулу хватит памяти для размещения *самого большого* объекта. Иначе неожиданной большой объект затрет следующий в массиве и испортит память.

В то же время, когда размер объекта варьируется, зря используется память. Место под каждый объект увеличено, поскольку большой объект может попасть в любое место. И если больших объектов мало, то память теряется каждый раз, когда вы помещаете в пул маленький объект. Это как проходить осмотр в аэропорту и положить свои ключи в поддон для чемодана.

Если у вас такая ситуация, то можно рассмотреть возможность разделить пул на <span name="pools">отдельные</span> пулы для объектов разного размера -- большие, как для чемоданов, и маленькие, как для ключей.

<aside name="pools">

Это общий подход для реализации ориентированных на скорость менеджеров памяти. Менеджер имеет несколько пулов для блоков разного размера. Когда вы запрашиваете блок памяти, он выбирается из пула подходящего размера.

</aside>

### Объекты не очищаются автоматически

У менеджеров памяти есть специальная функция в режиме отладки, когда они заполняют только что выделенную или освобожденную память специальными значениями, типа `0xdeadbeef`. Это помогает вытащить наружу сложные шибки, которые вызваны использованием переменных, которые не инициализированы, или используют память после того, как она была освобождена.

Поскольку наш пул объектов не пользуется менеджером памяти, мы теряем эту полезную функцию. Хуже того, память под новый объект содержит данные предыдущего объекта. Из-за этого почти невозможно узнать, что вы забыли инициализировать объект: память хранит старые значения от прошлого объекта, которые выглядят *практически* корректными.

Следует внимательно следить за тем, что код, который создает объект в пуле *полностью* инициализирует объект. Возможно стоит даже потратить время на добавление специального поведения, которое <span name="clear">очищает</span> память перед тем, как запросят новый объект.

<aside name="clear">

Почту за честь, если вы будете использовать `0x1deadb0b`.

</aside>

### Объекты занимают память, даже если не используются

Пулы объектов редко встречаются в системах с автоматической сборкой мусора, потому что менеджер сам заботиться о том, чтобы не было дефрагментации памяти. Но пулы все равно пригодятся, если нужно нивелировать затраты на размещение и уничтожение ресурсов, особенно на мобильных устройствах с медленными процессорами и простыми стратегиями сборки мусора.

Если вы используете пул объектов, может возникнуть потенциальный конфликт. Поскольку пул не уничтожает объекты на самом деле, они все ещё находятся в памяти. И если они содержат ссылки на *другие* объекты, это не позволит сборщику собрать неиспользуемую память. Чтобы избежать такого поведения, очищайте ссылки в объекте, когда возвращаете его в пул.

## Пример

Системы частиц реального мира чаще всего добавляют гравитацию, ветер, трение и другие физические эффекты. Наш самый простой пример будет просто двигать частицы по прямой линии в течении пары кадров и убивать их после этого. Для блокбастера не подходит, но для демонстрации работы пула и как его использовать -- вполне.

Начнем с минимального кода. Сперва, маленький класс для частицы:

^code 1

Конструктор по умолчанию инициализирует частицу в состояние "свободна". Вызов метода `init()` позже переводит частицу в живое состояние.

Частицы анимированы с помощью метода, логично названного `animate()`, который вызывается один раз каждый кадр.

Пулу необходимо знать, какие частицы свободны для использования. Это можно узнать, вызвав функцию `inUse()` у частицы. Эта функция использует факт, что  частицы живут несколько кадров, и можно использовать переменную `_framesLeft` чтобы понять, сколько частиц свободно без добавления отдельного флага.

Класс пула также прост:

^code 2

Функция `create()`  позволяет внешнему коду создавать новые частицы. Игра вызывает <span name="update">`animate()`</span> каждый кадр. Которая, в свою очередь, вызвает метод анимации у каждой частицы в пуле.

<aside name="update">

Метод `animate()` -- это пример паттерна <a href="update-method.html" class="pattern">Update Method</a>.

</aside>

Сами частицы храняться в массиве фиксированного размера внутри класса. В этой простой реализации, размер пула известен заранее, в объявлении класса. Но можно и определить его снаружи и использовать динамические массивы, или использовать шаблонные реализации с размером.

Создание новой частицы довольно просто:

^code 3

Проходим по всему пулу и ищем первую свободную. Инициализируем её и все. В этом варианте, если свободной частицы нет, то мы просто не создадим новую.

Мы коснулись только самой простой системы частиц, не затрагивая систему отображения, конечно же. Мы можем сейчас создать пул и несколько частиц, которые автоматически деактивируются, когда их время закончится.

Этого достаточно, чтобы выпустить игру, но внимательный глаз заметит, что создание новой частицы требует <span name="create">прохода</span> по массиву, возможно полного прохода, до тех пор, пока мы не найдем пустую частицу. Если пул достаточно большой и заполнен почти полностью, то этот процесс затянется. Посмотрим, как мы можем этого избежать.

<aside name="create">

Создание частицы имеет сложность O(n). Это для тех, кто помнит, что это значит.

</aside>

### Список свободных объектов

Если задаться целью не тратить время на *поиск* свободных частиц, то очевидный ответ -- это не упускать их из виду с самого начала. Мы можем устроить дополнительный список указателей на неиспользуемые частицы. Теперь, когда нам нужно создать частицу, мы достаем первый указатель из этого списка и используем частицу, на который он указывает.

К сожалению, это ведет к ещё одному отдельному массиву, который может по размерам сравняться с основным. В конце  концов, когда мы только создаем пул, *все* частицы в нем свободны, так что вспомогательный массив изначально содержит все частицы из списка.

Было бы здорово избежать проблем, *не занимая* памяти дополнительно. Например, мы можем воспользоваться памятью, где уже лежат эти свободные частицы. 

Когда частица свободна, то большинство её аттрибутов не имеют смысла. Координаты и скорость у свободной частицы не используются. Единственное что нужно -- это указание того, что частица дествительно мертва. В нашем примере, это поле `_framesLeft`. Все остальные биты можно использовать под свои нужды. Вот как это выглядит:

^code 4

Мы взяли все поля, кроме `framesLeft_`, и поместили их в <span name="union">объединение</span> `state_`. Эта структура содержит данные, которые используются при анимации. Когда частица не занята, то используется только `next` из этого объединения. Это указатель на следующую свободную частицу.

<aside name="union">

Объединения не часто используются в наши дни, так что синтаксис может показаться новым. Если вы работаете в команде, у вас наверняка есть гуру, чья задача решать трудности, из-за которых игра выбивается из бюджета. Спросите у него насчет объединений -- узнаете и о них, и о других прикольных трюках с упаковкой данных.

</aside>

Можно использовать эту указатели, чтобы построить связный список из свободных частиц. При это дополнительной памяти использоваться не будет. Вместо этого, мы утилизируем память, которая не приносит пользы в данный момент, чтобы хранить наш список.

Это умная техника называется [*свободный список*](http://en.wikipedia.org/wiki/Free_list). Для того, чтобы это заработало, надо правильно инициализировать указатель и следить за ним, когда частица создается и уничтожается. И, конечно, надо где-то хранить начало списка:

^code 5

Когда пул создается, *все* частицы свободны, так что этот свободный список проходит через все частицы. За это отвечает конструктор:

^code 6

Теперь, чтобы создать новую частицу, мы просто вытаскиваем <span name="first">первую</span> свободную:

<aside name="first">

Сложность O(1)!

</aside>

^code 7

Когда частица умирает, мы кладем её обратно в этот список:

^code 8

Вот так, маленький пул объектов, который тратит константное время на создание и удаление объектов.

## Архитектурные решения 

Простейшая реализация пула почти тривиальна: создать массив объектов и переинициализация их, когда понадобится. В реальной жизни бывают случаи посложнее. Если несколько способов сделать пул более типизированным, безопасным, или простым в использовании. Когда вы приступите к реализации пула в своем коде, придется ответить на следующие вопросы:

### Объекты привязаны к пулу?

Первый вопрос, с которым вы столкнетесь, это должны ли объекты знать о пуле, в котором они лежат. Большую часть времени -- да, но хочется сделать пул как можно более общим, без указания на класс, который он будет поддерживать.

* **Когда объекты привязаны к пулу:**

     *  *Реализация проста.* Можно просто добавить флаг или функцию типа "я свободен" в объект.

     *  *Объекты будут создаваться только пулом.* В C++ можно сделать пул friend-классом объекта и закрыть публичный конструктор.

        ^code 10

        Эта связь показывает механизм работы с объектом и уведомляет программиста, что не надо создавать объекты вне пула.

     *  *Можно попробовать избежать явного флага занятости.* Большинство объектов содержать информацию, которую можно использовать в качестве подобного флага. Например, частица может быть свободна, если её координаты находятся вне экрана. Когда объект используется в пуле, то метод `inUse()` может использовать эту информацию. Это поможет сэкономить немного места.

* **Если объект и пул не связаны:**

     *  *Можно использовать пул под любые классы.* Довольно сильное преимущество. Можно написать пул, которому вообще не нужно будет знать о классе, который он хранить.

     *  *Флаг занятости придется отслеживать снаружи.* В простейшем случае для этого добавляется набор флагов.

        ^code 11

### Кто инициализирует объект?

Когда вы воскрешаете объект, его надо как-то инициализировать. Ключевой момент здесь -- делать это внутри пула или снаружи.

* **Если этим занимается пул:**

     *  *Объекты полностью инкапсулированы в пуле*. Если вам немного нужно от самих объектов, то их вообще можно спрятать внутри пула. Тогда не будет проблем с тем, что кто-то получает указатель на мертвую частицу.

     *  *Пул жестко привязан к вариантам инициализации*. Объект пула может предоставить несколько функций для инициализации. Если пул этим занимается, то его интерфейс должен поддерживать все варианты и делегировать вызовы к создаваемому объекту.

        ^code 12

* **Если инициализировать снаружи:**

     *  *Интерфейс пула становиться проще.* Вместо того, чтобы покрывать все варианты инициализации, пул может просто возвращать ссылку на новый объект.

        ^code 13

        И тогда уже вызывающая сторона будет проводить необходимую инициализацию.

        ^code 14

     *  *Нужно учесть, что получение нового объекта может сорваться.* В предыдущем примере предполагается, что `create()` всегда вернет валидный указатель на объект. Если пул заполнен, то можно в ответ получить `NULL`. Чтоб обезопаситься, надо проверять это перед использованием указателя.

        ^code 15

## Что ещё

*   Все это очень похоже на <a class="gof-pattern" href="flyweight.html">Flyweight pattern</a>. Оба содержат список переиспользуемых объектов. Отличие в разном смысле слова "переиспользовать". Легкие объекты используются несколькими владельцами *одновременно*. Это экономит память, когда вы используете один и тот же объект в разных контекстах.

    Объекты пула тоже используются вторично, но только со временем. "Использование" в контексте пула означает, что память используется заново, когда предыдущему владельцу она уже *не нужна*. Пул не предполагает одновременной работы с живым объектом из нескольких мест.  

* Упаковка набора объектов одного типа рядом друг с другом положительно сказываться на кэше просессора. Глава <a class="pattern" href="data-locality.html">Компактность данных</a> рассматривает эту тему.
