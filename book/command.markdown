^title Команда
^section Повторяем паттерны проектирования

Команда - один из моих любимых паттернов. В большинстве больших программ, которые я пишу, будь то игры или что-то другое, употребляется этот паттерн. При использовании в нужном месте он аккуратно распутывает действительно кривой код. Для такого раздутого паттерна у "Банды четырех" есть предсказуемо малопонятное определение:

> Инкапсулируйте запрос в качестве объекта, тем самым позволяя пользователям параметризовать клиентов с различными запросами, поставьте в очередь или запишите запросы в журнал и организуйте поддержку отменяемых операций.

Согласитесь, страшное предложение? Прежде всего, оно искажает все, что бы эта метафора ни пыталась заключить. Вне странного мира программного обеспечения, где слова могут означать всё, что угодно, "клиент" -- это человек, с которым ведут бизнес. Вплоть до настоящего времени людей нельзя было "параметризовать".

Далее, оставшаяся часть предложения - это просто список того, к чему, вероятно, можно применить данный паттерн. Не очень понятно, если вашего сценария использования нет в этом списке. *Мой* сжатый слоган для паттерна "Команда" будет звучать так:

**Команда - это *<span name="latin">материализованный</span> вызов метода*.**

<aside name="latin">

"Материализовать" ("reify") происходит от латинского "res" — "вещь", с добавлением английского суффикса "&ndash;fy". Поэтому это слово буквально значит "овеществлять" ("thingify"), что, честно говоря, гораздо больше подошло бы в качестве определения.

</aside>

Конечно, под словом "сжатый" часто подразумевается "предельно краткий", поэтому определение паттерна, вероятно, не очень улучшилось. Позвольте мне предложить немного более развернутое описание. "Материализовать" (если вы никогда не слышали этого слова) означает "сделать реальным". Другим термином для определения слова "материализовать" является сделать что-то объектом "первого класса".

<aside name="reflection">

*Системы рефлексии* в некоторых языках программирования позволяют работать с типами в программе императивно во время выполнения. Можно получить объект, представляющий класс другого объекта, и поиграть с ним, чтобы увидеть, что умеет делать тип. Другими словами, рефлексия - это *материализованная система типов*.

</aside>

Оба выражения подразумевают взятие некоего <span name="reflection">*концепта*</span> и превращение его в кусок *данных* -- объект -- который можно поместить в переменную, передать на вход функции и т.д. Таким образом, называя паттерн "Команда" "вызовом материализованного метода", я имею в виду, что это вызов метода, обернутый в объект.

Это во многом похоже на "функцию обратного вызова", "функцию первого класса", "указатель на функцию", "замыкание" или "частично применяемую функцию", в зависимости от того, на каком языке программирования вы пишете, и, на самом деле, все это растения из одного сада. Далее "Банда четырёх" пишет:

> Команды - это объектно-ориентированная замена функций обратного вызова.

Это определение стало бы намного более удачным для паттерна, нежели то, которое они выбрали.

Но все это абстрактно и туманно. Я люблю начинать главы с конкретики, а в этот раз у меня это не получилось. Чтобы восполнить эту досадную оплошность, с текущего момента и дальше будут только сухие примеры, в которых команды найдут блестящее применение.

## Настройка ввода

В любой игре где-то есть кусок кода, который считывает необработанные данные пользователя с устройств ввода -- нажатия кнопок, клавиатурные события, щелчки мышью - что угодно. Он каждый раз берет входные данные и преобразует их в имеющее смысл действие в игре:

<img src="images/command-buttons-one.png" alt="Контроллер с кнопкой A, привязанной к swapWeapon(), B, привязанной к lurch(), X, привязанной к jump(), и Y, привязанной к fireGun()." />

Самая простая реализация выглядит примерно так:

<span name="lurch"></span>

^code handle-input

<aside name="lurch">

Профессиональный совет: не нажимайте "B" слишком часто.

</aside>

Эта функция обычно вызывается раз в кадр паттерном <a class="pattern" href="game-loop.html">"Игровой цикл"</a>, и я уверен, вы сможете понять, что она делает. Она работает, если мы хотим жестко привязать кнопки ввода к игровым действиям, но многие игры разрешают пользователям *настроить* привязку кнопок.

Чтобы поддерживать это, нужно поменять прямые вызовы `jump()` и `fireGun()` на что-то, что можно изменить. "Изменить" звучит во многом, как определить переменную, поэтому нужен *объект*, который можно использовать для отображения игрового действия. Встречайте: паттерн "Команда".

Определим базовый класс, представляющий срабатываемую игровую команду:

<span name="one-method"></span>

^code command

<aside name="one-method">

Если есть интерфейс с единственным методом, который ничего не возвращает, очень вероятно, что это паттерн "Команда".

</aside>

Затем создаем подклассы для каждого из различных игровых действий:

^code command-classes

В обработчике входных данных сохраним указатель на команду для каждой кнопки:

^code input-handler-class

Теперь обработка входных данных просто делегирует полномочия:

<span name="null"></span>

^code handle-input-commands

<aside name="null">

Обратили внимание, что здесь мы не проверяем на равенство `null`? Следовательно, предполагается, что каждая кнопка будет иметь *некоторую* привязанную к ней команду.

Если мы хотим поддерживать бездействующие кнопки без необходимости явно проверять на равенство `null`, можно определить класс команды, чей метод `execute()` ничего не делает. Затем вместо того, чтобы установить обработчик кнопки в `null`, делаем его указателем на тот объект.
Это паттерн, называемый ["Нулевым объектом"](http://ru.wikipedia.org/wiki/Null_object_%28%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%29).

</aside>

Там, где при вводе использовался прямой вызов функции, теперь появился слой абстракции:

<img src="images/command-buttons-two.png" alt="Контроллер, где каждая кнопка привязана к соответствующей переменной 'button_', которая в свою очередь привязана к функции." />

В этом суть паттерна "Команда". Если вы уже видите его преимущество, рассматривайте оставшуюся часть главы, как бонус.

## Директивы для акторов

Только что определенные классы команд приемлемы в предыдущем примере, но весьма ограничены. Проблема в том, что они предполагают существование высокоуровневых функций `jump()`, `fireGun()` и прочих, неявно знающих, как найти аватар игрока и заставить его танцевать, как марионетку, которой он и является.

Эта предполагаемая связь ограничивает пользу данных команд. *Единственный*, кто может подпрыгнуть по команде `JumpCommand` - это игрок. Давайте ослабим это ограничение. Вместо вызова функций, самостоятельно находящих объект команды, *передадим на вход* объект, которым хотим управлять:

^code actor-command

Здесь `GameActor` - класс "игрового объекта", представляющий персонажа в игровом мире. Передаем его в `execute()`, чтобы унаследованная команда могла вызвать методы, применяя их к выбранному актору, например:

^code jump-actor

Теперь можно использовать этот единственный класс, чтобы заставить прыгать любого персонажа в игре. Нам просто не хватает кусочка между обработчиком пользовательского ввода и командой, который бы принимал команду и вызывал её на правильном объекте. Сначала изменим `handleInput()` так, чтобы он *возвращал* команды:

^code handle-input-return

Он не может выполнить команду немедленно, потому что не знает, какого актора передать на вход. Вот где мы воспользуемся тем фактом, что команда является материализованным вызовом -- можно *отложить* выполнение вызова.

Далее нужен какой-то код, который берет команду и запускает на акторе, представляющем игрока. Что-то вроде этого:

^code call-actor-command

Предположим, что `actor` - это ссылка на персонаж игрока, тогда этот код правильно передвигает его согласно управляющим клавишам пользователя, поэтому мы возвращаемся к тому же поведению из первого примера. Но добавление уровня абстракции между командой и выполняющим ее актором дает небольшое изящное преимущество: *теперь можно позволить игроку управлять любым актором в игре, просто сменив актора, на котором выполняются команды.*

На практике это не распространенная возможность, но есть аналогичный сценарий использования, *действительно* часто всплывающий. До сих пор мы рассматривали только управляемого игроком персонажа, но что насчет других акторов в мире? Они управляются искусственным интеллектом игры. Можно использовать тот же самый паттерн "Команда" в качестве интерфейса между движком искусственного интеллекта и акторами: код искусственного интеллекта просто генерирует объекты `Command`.

Здесь декомпозиция искусственного интеллекта, выбирающего команды, и кода актора, выполняющего их, предоставляет хороший уровень гибкости. Можно использовать различные модули искусственного интеллекта для различных акторов. Или можно смешать и сопоставить куски искусственного интеллекта для различных видов поведения. Хотите получить более агрессивного врага? Просто подключите более агрессивный искусственный интеллект, чтобы генерировать команды для него. Фактически можно даже прицепить искусственный интеллект к персонажу *игрока*, что может быть полезно для таких вещей, как демо-режим, когда игра должна работать на автопилоте.

<span name="queue">Путем</span> превращения команд, управляющих актором, в объекты первого класса, мы убрали жесткую зависимость от прямого вызова метода. Вместо этого получилось что-то вроде очереди или потока команд:

<aside name="queue">

Намного больше о том, что может сделать постановка в очередь, вы найдете в главе <a href="event-queue.html" class="pattern">"Очередь событий"</a>.

</aside>

<span name="stream"></span>

<img src="images/command-stream.png" alt="Поток, соединяющий искусственный интеллект с актором." />

<aside name="stream">

Почему я чувствую потребность нарисовать картинку "потока" для вас? И почему он выглядит, как труба?

</aside>

Некоторый код (обработчик пользовательского ввода или искусственный интеллект) <span name="network">генерирует</span> команды и помещает их в поток. Другой код (диспетчер или сам актор) получает команды и вызывает их. Поместив очередь в центр, мы сделали декомпозицию генератора на одном конце от потребителя на другом.

<aside name="network">

Если взять эти команды и сделать их *сериализуемыми*, то можно послать поток из них по сети. Мы можем взять данные, введенные игроком, послать их по сети на другую машину и затем повторно воспроизвести их. Это важная часть создания сетевой многопользовательской игры.

</aside>

## Отмена и повтор

Последний пример - наиболее известное применение данного паттерна. Если объект команды может что-то *делать*, малый шаг отделяет его от возможности *отмены* своих действий. Отмена используется в некоторых стратегических играх, где можно откатить шаги, которые не понравились. Это *дань этикету* в инструментах, используемых для *создания* игр. <span name="hate">Самый надежный способ</span> заставить гейм-дизайнеров ненавидеть вас - дать им редактор уровней, который не может отменять ошибки, допущенные с помощью их толстых пальцев.

<aside name="hate">

Возможно, сейчас я рассуждаю, исходя из своего опыта.

</aside>

Без паттерна "Команда" реализация отмены действия на удивление сложна. С ним - это пара пустяков. Давайте предположим, что делаем однопользовательскую пошаговую игру и хотим разрешить пользователям отменять шаги, чтобы они могли больше сосредоточиться на стратегии и меньше на угадывании.

Мы уже используем удобные команды для абстрагирования обработки входных данных, поэтому каждый шаг, производимый игроком, инкапсулирован в них. Например, перемещение единицы техники может выглядеть так:

^code move-unit

Обратите внимание, что есть маленькое отличие от предыдущих команд. В последнем примере мы хотели *абстрагировать* команду от модифицированного ею актора. В данном случае мы специально хотим *привязать* ее к перемещаемой единице техники. Экземпляр данной команды не является обобщённой операцией вида "двигать что-то", которую можно использовать во многих ситуациях; это определенное конкретное перемещение в игровой последовательности шагов.

В этом разница в реализации паттерна "Команда". В некоторых случаях, например, в первой паре примеров, команда - это объект многократного использования, представляющий *что-то, что можно сделать*. Предыдущий обработчик входных данных закреплялся за единственным объектом команды и вызывал его метод `execute()` каждый раз, когда была нажата верная кнопка.

Здесь команды более специфичны. Они представляют что-то, что может быть сделано в определённый момент времени. Это означает, что код обработки входных данных будет <span name="free">*создавать*</span> экземпляр каждый раз, когда игрок выберет шаг. Что-то вроде этого:

^code get-move

<aside name="free">

Конечно, в языках без сборки мусора, например C++, это означает, что код, выполняющий команды, также будет отвечать за освобождение памяти из-под них.

</aside>

Факт того, что команды используются только один раз, за секунду станет нашим преимуществом. Для того чтобы сделать команды отменяемыми, определим другую операцию, которую потребуется реализовать каждому классу команды:

^code undo-command

Метод `undo()` возвращает игровое состояние, измененное соответствующим методом `execute()`. Вот предыдущая команда перемещения с поддержкой отмены:

^code undo-move-unit

Обратите внимание, что мы добавили к классу <span name="memento">больше состояний</span>. Когда единица техники перемещается, она забывает, где была ранее. Если мы хотим иметь возможность отменять перемещение, то должны сами запоминать предыдущую позицию единицы, что и делают `xBefore_` и `yBefore_`.

<aside name="memento">

Кажется, тут место для паттерна <a href="https://ru.wikipedia.org/wiki/%D0%A5%D1%80%D0%B0%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C_%28%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%29" class="gof-pattern">"Хранитель"</a>, но я не видел, чтобы он где-то хорошо справлялся с работой. Так как команды, как правило, изменяют небольшую часть состояния объекта, фиксация остальных его данных - потеря памяти. Выгоднее вручную хранить только изменяемые биты.

<a href="http://en.wikipedia.org/wiki/Persistent_data_structure">*Персистентные структуры данных*</a> являются альтернативой. С ними каждое изменение объекта возвращает новый объект, оставляя оригинал неизменным. Посредством умной реализации эти новые объекты используют данные совместно с предыдущими, поэтому это гораздо проще, чем клонирование целого объекта.

Используя персистентную структуру данных, каждая команда хранит ссылку на объект перед выполнением, а отмена просто является переключением обратно к старому объекту.

</aside>

Чтобы позволить игроку отменить шаг, придерживаем последнюю команду, которую он выполнил. Когда игрок ударяет по Control-Z, вызываем метод команды `undo()`. (Если игрок уже делал отмену, тогда метод превращается в "redo", и мы выполняем команду снова.)

Поддержка нескольких уровней отмены действия не намного сложнее. Вместо того, чтобы запомнить последнюю команду, храним список команд и ссылку на текущую. Когда игрок выполняет команду, помещаем ее в конец списка и ставим туда указатель "текущей" команды.

<img src="images/command-undo.png" alt="Стек команд от самой старой к самой новой. Стрелка 'текущая' указывает на команду, стрелка 'отмена' указывает на предыдущую команду, а 'повтор' указывает на следующую." />

Когда игрок выбирает "Отмену", отменяем текущую команду и перемещаем текущий указатель назад. Когда игрок выбирает <span name="replay">"Повтор"</span>, перемещаем указатель вперед, а затем выполняем эту команду. Если игрок выбирает новую команду после отмены какой-то, все в списке после текущей команды отбрасывается.

В первый раз после реализации этого в редакторе уровней я почувствовал себя волшебником. Я был поражен простотой реализации и тем, насколько хорошо все работало. Требуется дисциплина, чтобы увериться в том, что каждое изменение данных проходит сквозь команду, но как только вы это сделаете, остальное будет просто.

<aside name="replay">

Повтор, возможно, не так распространен в играх, но повторное *воспроизведение* - да. В ходе простейшей реализации мы бы записали состояние всей игры в каждом кадре, чтобы ее можно было повторно воспроизвести, но это бы потребовало слишком много памяти.

Вместо этого, многие игры записывают набор команд, выполняемых каждой сущностью каждый кадр. Для повторного воспроизведения движок просто запускает симуляцию обычной игры, выполняя предварительно записанные команды.

</aside>

## Classy and Dysfunctional?

Earlier, I said commands are similar to first-class functions or closures, but
every example I showed here used class definitions. If you're familiar with
functional programming, you're probably wondering where the functions are.

I wrote the examples this way because C++ has pretty limited support for
first-class functions. Function pointers are stateless, functors are weird and
still
require defining a class, and the lambdas in C++11 are tricky to work with
because of manual memory management.

That's *not* to say you shouldn't use functions for the Command pattern in other
languages. If you have the luxury of a language with real closures, by all means,
use them! In <span name="some">some</span> ways, the Command pattern is a way of
emulating closures in languages that don't have them.

<aside name="some">

I say *some* ways here because building actual classes or structures for
commands is still useful even in languages that have closures. If your command
has multiple operations (like undoable commands), mapping that to a single
function is awkward.

Defining an actual class with fields also helps readers easily tell what data
the command contains. Closures are a wonderfully terse way of automatically
wrapping up some state, but they can be so automatic that it's hard to see what
state they're actually holding.

</aside>

For example, if we were building a game in JavaScript, we could create a move
unit command just like this:

    :::javascript
    function makeMoveUnitCommand(unit, x, y) {
      // This function here is the command object:
      return function() {
        unit.moveTo(x, y);
      }
    }

We could add support for undo as well using a pair of closures:

    :::javascript
    function makeMoveUnitCommand(unit, x, y) {
      var xBefore, yBefore;
      return {
        execute: function() {
          xBefore = unit.x();
          yBefore = unit.y();
          unit.moveTo(x, y);
        },
        undo: function() {
          unit.moveTo(xBefore, yBefore);
        }
      };
    }

If you're comfortable with a functional style, this way of doing things is
natural. If you aren't, I hope this chapter helped you along the way a bit. For
me, the usefulness of the Command pattern really shows how effective the
functional paradigm is for many problems.

## See Also

 *  You may end up with a lot of different command classes. In order to make it
    easier to implement those, it's often helpful to define a concrete base
    class with a bunch of convenient high-level methods that the derived
    commands can compose to define their behavior. That turns the command's main
    `execute()` method into a <a href="subclass-sandbox.html"
    class="pattern">Subclass Sandbox</a>.

 *  In our examples, we explicitly chose which actor would handle a command. In
    some cases, especially where your object model is hierarchical, it may not
    be so cut-and-dried. An object may respond to a command, or it may decide to
    pawn it off on some subordinate object. If you do that, you've got yourself
    a <a class="gof-pattern" href="
    http://en.wikipedia.org/wiki/Chain-of-responsibility_pattern">Chain of Responsibility</a>.

 *  Some commands are stateless chunks of pure behavior like the `JumpCommand`
    in the first example. In cases like that, having <span
    name="singleton">more</span> than one instance of that class wastes memory
    since all instances are equivalent. The <a class="gof-pattern"
    href="flyweight.html">Flyweight</a> pattern addresses that.

    <aside name="singleton">

    You could make it a <a href="singleton.html" class="gof-
    pattern">Singleton</a> too, but friends don't let friends create singletons.

    </aside>
