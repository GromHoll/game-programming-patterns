<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />

<title>Data Locality &middot; Низкоуровневая оптимизация &middot; Game Programming Patterns</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />
<link href="http://fonts.googleapis.com/css?family=Merriweather:400,400italic,700,700italic|Source+Code+Pro|Source+Sans+Pro:200,300,400,600,400italic,600italic|Rock+Salt" rel="stylesheet" type="text/css">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-1', 'gameprogrammingpatterns.com');
  ga('send', 'pageview');
</script>
<script src="jquery-1.10.1.min.js"></script>
<script src="script.js"></script>
</head>
<body id="top">
<div class="page sidebar">
<div class="content">
<h1>Data Locality</h1>
<h1 class="book"><a href="/">Game Programming Patterns</a><span class="section"><a href="optimization-patterns.html">Низкоуровневая оптимизация</a></span></h1>
<h2><a href="#общая-мысль" name="общая-мысль">Общая мысль</a></h2>
<p><em>Если расположить данные в памяти специальным образом, то это поможет кэшам процессора.</em></p>
<h2><a href="#предыстория" name="предыстория">Предыстория</a></h2>
<p>Нас обманули. Нам показывают графики, на которых скорость процессоров растёт все выше и выше, как будто закон Мура - это не просто историческое наблюдение, а какое-то непререкаемое правило. Не отрывая задниц от кресла, мы, программисты, наблюдаем, как наши программы волшебным образом ускоряются благодаря апгрейду.</p>
<p>Процессоры <em>ускорялись</em> (сейчас график больше похож на плато), но главные по железу забыли нам кое-что сказать. Конечно, мы можем <em>обработать</em> данные быстрее чем раньше, но мы не можем <em>получить</em> их быстрее.</p>
<p><span name="legend"></span></p>
<p><img src="images/data-locality-chart.png" /></p>
<aside name="legend">
<p>Скорость процессора и доступа к памяти относительно уровня 1980-го года. Как видно, скорость процессоров растет как на дрожжах, а вот доступ к памяти плетётся далеко позади.</p>
<p>Данные взяты из &#8220;Computer architecture: a quantitative approach&#8221; John L. Hennessy, David A. Patterson, Andrea C. Arpaci-Dusseau by way of Tony Albrecht&#8217;s &#8220;<a href="http://research.scee.net/files/presentations/gcapaustralia09/Pitfalls_of_Object_Oriented_Programming_GCAP_09.pdf">Pitfalls of Object-Oriented Programming</a>&#8220;.</p>
</aside>
<p>Для того, чтобы сверхбыстрый процессор провернул свои вычисления, ему, вообще-то, нужно выгрузить данные из главной памяти в свои регистры. И как видите, память не так быстра, как скорость процессора. Даже близко не так.</p>
<p>С современным уровнем развития железа, может понадобиться <em>сотни</em> тактов, чтобы вытащить байт из <span name="ram">RAM</span>. Если большинство операций связано с данными, и нужно сотни тактов, чтобы их получить - как так получается, что наши процессоры не бездельничают 99% времени, ожидая поступления данных?</p>
<p>На самом деле, они <em>действительно</em> ждут памать удивительно большую часть своего времени, но все не так плохо, как это могло бы быть. Чтобы объяснить почему, давайте совершим сделаем длинное лирическое отступление&#8230;</p>
<aside name="ram">
<p>Она называется RAM (&#8220;Random access memory&#8221;) потому что можно получить доступ к любому участку памяти одинаково быстро (это в теории). То есть не нужно считывать все байты по очереди, чтоб добраться до нужного места.</p>
<p>Ну, <em>обычно</em> не нужно. Как будет видно дальше, RAM не всегда настолько гибка, как кажется.</p>
</aside>
<h3><a href="#хранилище-данных" name="хранилище-данных">Хранилище данных</a></h3>
<p>Представьте, что вы&#8202;&mdash;&#8202;бухгалтер в маленьком офисе. Ваша работа: получить коробку документов и сделать с ними что-нибудь <span name="accountant">бухгалтерское</span>. Например, сложить какие-то числа. Это нужно сделать только с документами из некоторых коробок, в соответствии с какими-то тайными правилами, которые понятны только другим бухгалтерам.</p>
<aside name="accountant">
<p>Наверное, не стоило здесь использовать бухгалтерию&#8202;&mdash;&#8202;я ничего в ней не понимаю.</p>
</aside>
<p>Благодаря тяжелой работе, природной упорности и стимуляторам, можно обработать всю коробку, скажем, за минуту. Но есть одна проблема - все эти коробки хранятся на складе в отдельном здании. Чтобы получить коробку, вам нужно попросить парня со склада принести её вам. Он идет, берет подъемник и ездит вдоль стеллажей, пока не найдет коробку, которая вам нужна.</p>
<p>Все это займет целый день, без шуток. В отличие от вас, парень со склада ещё не скоро станет работников месяца. Это значит, что неважно насколько вы быстры&#8202;&mdash;&#8202;вы все рано получите не больше одной коробки в день. Все остальное время вы будете просто сидеть и думать о жизни, которая привела вас к такой бессмысленной работе.</p>
<p>И вот однажды, появилась группа специалистов. Их работа&#8202;&mdash;&#8202;увеличивать эффективность работы. Придумывать маленькие хаки, которые позволяют сборочной линии двигаться быстрее. Они понаблюдали за вами несколько дней, и сделали несколько замечаний:</p>
<ul>
<li>
<p>Довольно часто, следущая коробка, которую вы попросите, находится <span name="next">на одной полке</span> с предыдущей.</p>
</li>
<li>
<p>Использовать подъемник, чтобы снять маленькую коробку с полки&#8202;&mdash;&#8202;довольно неэффективная идея.</p>
</li>
<li>
<p>И в вашем офисе есть немного места в углу.</p>
</li>
</ul>
<aside name="next">
<p>Эта ситуация (когда вы используете вещь, которая лежала рядом с той, которую вы только что использовали) в техническом мире называется <em>компактность ссылок</em>.</p>
</aside>
<p>Это дельный совет. Теперь, когда вы запрашиваете коробку у парня со склада, он приносит вам целую палету. Не только коробку, которая вам нужна, но и несколько соседних тоже. Он не знает, понадобятся ли они вам (вообще говоря, ему просто по барабану)&#8202;&mdash;&#8202;он просто берет столько коробок, сколько может унести.</p>
<p>Итак, он загружает целую палету и несет её вам. Игнорируя правила безопасности, он въезжает на подъемнике прямо к вам в офис и сгружает все это прямо у вас в углу.</p>
<p>Когда вам нужна будет новая коробка, вы первым делом смотрите в углу&#8202;&mdash;&#8202;возможно следущая коробка уже там. Если она действительно там, то вам повезло! Вам нужна всего секунда, чтобы взять новую коробку и занятся магией чисел. Если в куче 50 коробок, и вам так повезло, что <em>все</em> следующие коробки находятся в куче, то вы можете сделать в 50 раз больше работы чем раньше.</p>
<p>Но, если коробка, которая вам нужна, в куче <em>отсутствует</em>, вам все-таки придется её заказать. Поскольку в угол влезает только одна палета, то парень со склада приедет, заберет старую кучу и затем привезет вам совершенно новую кучу.</p>
<h3><a href="#куча-для-процессора" name="куча-для-процессора">Куча для процессора</a></h3>
<p>Может показаться странным, но в современных компьютерах процессоры работают точно также. Офисный стол бухгалтера - это регистры процессора, а коробка с документами&#8202;&mdash;&#8202;данные, которые можно положить в регистры. Склад&#8202;&mdash;&#8202;это RAM вашего компьютера, а тот надоедливый парень со склада&#8202;&mdash;&#8202;шина, которая наполняет регистры данными из памяти.</p>
<p>Если бы эта книга писалась тридцать лет назад, здесь история бы и закончилась. Но так как процессоры становятся быстрее, а RAM, грубо говоря, <em>нет</em>, инженеры начали искать решение. И они пришли к тому, что называется <em>кэшем процессора</em>.</p>
<p>В современных компьютеры если  <span name="caches">маленький объем</span> памяти прямо внутри процессора. Он может достать оттуда данные быстрее, чем из основной памяти. Этот объем достаточно мал, чтобы уместиться в процессоре, и довольно дорог, потому что используется особый, быстрый тип памяти (static RAM или &#8220;SRAM&#8221;).</p>
<aside name="caches">
<p>Вообще, кэшей несколько. В зависимости от уровня они называются по-разному&#8202;&mdash;&#8202;&#8221;L1&#8221;, &#8220;L2&#8221;, &#8220;L3&#8221; и так далее. Каждый уровень больше и медленнее предыдущего. В этой главе мы не будем углубляться в детали <a href="http://ru.wikipedia.org/wiki/Иерархия_памяти">иерархии памяти</a>, но это полезно знать.</p>
</aside>
<p>Этот маленький кусочек памяти называется <em>кэшем</em> (в частности, этот можно назвать <em>кэш L1</em>), и в нашей истории он эквивалентен куче коробок. Как только процессору понадобится байт памяти из RAM, он автоматически забирает целый кусок непрерывных данных&#8202;&mdash;&#8202;обычно от 64 до 128 байт&#8202;&mdash;&#8202;и кладет их в кэш. Эта порция памяти называется <em>кэш-линией</em>.</p>
<p><img src="images/data-locality-cache-line.png" /></p>
<p>Если <span name="pallet">следующий байт</span> данных, который вам нужен, случайно окажется к этой линии, процессор прочитает его прямо из кэша, что <em>гораздо</em> быстрее чем обращение к RAM. Эту ситуацию, когда данные в кеше, называют <em>попаданием в кэш</em>. Если данных нет в кеше и приходится запрашивать главную память&#8202;&mdash;&#8202;это <em>кэш-промах</em>.</p>
<aside name="pallet">
<p>Я приукрасил одну (по крайней мере) деталь в нашей истории. В офисе можно положить только одну кучу, то есть одну кэш-линию. Кэш процессора содержит несколько кэш-линий. Вы сможете утолить свое любопытство, поискав по слову &#8220;ассоциативность кэша&#8221;.</p>
</aside>
<p>Когда случается кэш-промах, процессор <em>замирает</em>: он не может выполнить инструкцию, потому что ему нужны данные. Он просто стоит и скучает следующие несколько сотен тактов пока данные не появятся. Наша задача&#8202;&mdash;&#8202;избежать этого. Допустим, мы хотит увеличить производительность важной части кода, который выглядит вот так:</p>
<div class="codehilite"><pre><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_THINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">sleepFor500Cycles</span><span class="p">();</span>
  <span class="n">things</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">doStuff</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p>Какой бы был ваш первый шаг? Правильно! Уберем этот бессмысленный и дорогой вызов функции. Вызов функции по стоимости эквивалентен кэш-промаху. Каждый раз вы выскакиваете в основную память&#8202;&mdash;&#8202;это как вставить задержку в код.</p>
<h3><a href="#разве-данные&#8202;&mdash;&#8202;это-производительность?" name="разве-данные&#8202;&mdash;&#8202;это-производительность?">Разве данные&#8202;&mdash;&#8202;это производительность?</a></h3>
<p>Когда я начал работать над этой главой, я потратил время на примеры , которые показали бы хороший и плохой вариант использования кэша. Мне нужны были тесты, которые гоняли бы кэш, чтобы непосредственно увидеть все эффекты.</p>
<p>И когда я сделал часть работы, я был удивлен. Я знал, что кэш важен, но увидеть это своими глазами&#8202;&mdash;&#8202;это нечто. <span name="ymmv">Я написал две программы</span>, которые делали <em>совершенно одинаковые</em> вещи. Единственное отличие было в том, как много кэш-промахов они получали. И худший вариант был в 50 <em>раз</em> медленнее, чем лучший.</p>
<aside name="ymmv">
<p>Здесь есть тонкости. В частности, разные компьютеры имеют разный кэш, поэтому мой комьютер может отличаться от вашего. А игровые консоли совсем отличны от дескторов, которые имеют много разного с мобильными устройствами.</p>
<p>Ваши результаты могут отличаться.</p>
</aside>
<p>Это по-настоящему открыло мне глаза. Я думал, на быстродействие влияет <em>код</em>, а не <em>данные</em>. Байт не бывает быстрым или медленным, он просто есть. Но из-за кэширования, <em>способ управления памятью прямо влияет на производительность</em>.</p>
<p>Теперь нужно все это применить к нашей теме. Оптимизация использования кэша&#8202;&mdash;&#8202;довольно объемная тема. Я даже не упомянул о <em>кэшировании инструкций</em>. Вспомните&#8202;&mdash;&#8202;код находится в памяти тоже, и его тоже нужно загрузить в процессор перед тем как выполнить. Кто-то более осведомленный может написать целую <span name="book">книгу</span> об этом.</p>
<aside name="book">
<p>На самом деле, кто-то <em>уже</em> написал книгу об этом:  <a href="http://www.dataorienteddesign.com/dodmain/"><em>Data-Oriented Design</em></a> от Ричарда Фабиана.</p>
</aside>
<p>Так как вы всё-таки читаете <em>эту</em> книгу, то я опишу несколько базовых вещей. Вместе с ними уже можно начать думать о том, как структуры данных влияют на производительность.</p>
<p>Все довольно просто: когда процессор считывать данные из памяти, он требует целую кэш-линию. Чем больше данных удасться <span name="line">положить в эту линию, тем быстрее все выполнится</span>. Так что надо <em>организовать ваши структуры так, чтобы вычисления оперировали с близко расположенными в памяти данными</em>.</p>
<aside name="line">
<p>Здесь есть ключевой момент:  контекст одного потока. Если вы модифицируете данные, используя несколько потоков, то лучше им находится в разных <em>кэш-линиях</em>. Если два потока попытаются изменить данные в одной и той же кэш-линии, обоим процессорам использовать синхронизацию кэшей, что довольно дорого.</p>
</aside>
<p>Другими словами, если ваш код использует <code>одно</code>, затем <code>другое</code>, потом <code>третье</code>, вам лучше расположить это в памяти как-то так:</p>
<p><img src="images/data-locality-things.png" /></p>
<p>Заметьте, это не <em>указатели</em> на <code>одно</code>, <code>другое</code> и <code>третье</code>. Это настоящие данные, расположенные в одну линию. Как только процессор потребует <code>одно</code>, он сразу же получит и <code>другое</code>, и <code>третье</code> (вообще это зависит от того, насколько эти штуки большие, и от размера кэш-линии). Когда начнуться вычисления, данные уже будут в кэше. Ваш процессор счастлив, значит&#8202;&mdash;&#8202;и вы счастливы.</p>
<h2><a href="#общий-подход" name="общий-подход">Общий подход</a></h2>
<p>Современные <strong>процессоры имеют кэш для ускорения доступа к памяти</strong>. Доступ к соседним участкам памяти <strong>осуществляется намного быстрее</strong>. Этим можно воспользоваться <strong>увеличивая компактность данных</strong>&#8202;&mdash;&#8202;хранить данные <strong>непрерывно, в соответствии с порядком их обработки</strong>.</p>
<h2><a href="#когда-этим-пользоваться" name="когда-этим-пользоваться">Когда этим пользоваться</a></h2>
<p>Как и при большинстве оптимизаций, первым делом нужно убедится что <em>есть проблема с быстродействием</em>. Не тратьте время, пытаясь ускорить редко используемый участок кода. Преждевременная оптимизация усложнит вашу жизнь, так как результат почти всегда сложен и менее гибок.</p>
<p>Применительно к нашей теме, нужно убедиться, что быстродействие <em>действительно страдает от кэш-промахов</em>. Если код медленный по другим причинам, то лекарство не поможет.</p>
<p>В простом случае выследить проблему поможет инструментация. Она измерит время выполнения кода между двумя точками с использованием точного таймера. Для отлова кэш-промахов понадобиться что-то посложнее. Нужно увидеть, как много случилось промахов, и в каком месте.</p>
<p>К счастью, есть <span name="cachegrind">профайлеры</span>, которые могут помочь. Придется потратить время на настройку такого профайлера и научится воспринимать его (часто непростые) отчеты, перед тем как приступить к главному действу по оптимизации структур с данными.</p>
<aside name="cachegrind">
<p>К сожалению, такие профайлеры недешевы. Если вы в команде, которая работает с консолями, у вас скорее всего уже есть какая-нибудь лицензия.</p>
<p>Если нет, то если бесплатный <a href="http://valgrind.org/docs/manual/cg-manual.html">cachegrind</a>. Он выполняет программу в эмуляторе процессора и показывает все операции с кэшем.</p>
</aside>
<p>Как уже говорилось, кэш-промахи <em>повлияют</em> на быстродействие вашей игры. И все же не увлекайтесь тратой времени на преждевременную оптимизацию кэша. Просто помните при разработке архитектуры&#8202;&mdash;&#8202;организовать структуры стоит так, чтобы они хорошо работали в кэше.</p>
<h2><a href="#особенности" name="особенности">Особенности</a></h2>
<p>Отличительный признак архитектуры программы&#8202;&mdash;&#8202;<em>абстрация</em>. Большая часть это книги рассказывает о том, как отвязать куски кода друг от друга так, чтобы они были легко изменяемы. В языках ООП это почти всегда означает интерфейсы.</p>
<p>В C++ использование интерфейсов предполагает доступ к объектам через <span name="virtual">указатели или ссылки</span>. Доступ через указатель означает прыжки в памяти, которые ведут к кэш-промахам&#8202;&mdash;&#8202;а мы стараемся их избежать.</p>
<aside name="virtual">
<p>Другая особенность интерфейсов&#8202;&mdash;&#8202;<em>виртуальные методы</em>. Для того чтобы вызвать такой метод, необходимо получить доступ к виртуальной таблице объекта и найти там указатель на функцию, которую необходимо вызвать. То есть, игра в указатели опять приводит к кэш-промахам.</p>
</aside>
<p>Для того, чтобы воспользоваться оптимизацией, придется пожертвовать частью абстракций. Чем больше вы концентрируете архитектуру программы вокруг компактности данных, тем меньше применения находится наследованию и интерфейсам&#8202;&mdash;&#8202;и всем их сильным сторонам. Серебрянной пули здесь нет, угодить всем не удасться. Тем веселее!</p>
<h2><a href="#примеры" name="примеры">Примеры</a></h2>
<p>Если заняться оптимизацией локальности данных, то можно придумать бесконечно много способов разложения ваши структур на кусочки, с которыми процессору будет удобно работать. Для общего понимания я покажу примеры основных реализаций этих идей. Мы рассмотрим их в контексте части игрового кода, но это общая техника, поэтому применить её возможно везде (как и все остальные паттерны).</p>
<h3><a href="#непрерывные-массивы" name="непрерывные-массивы">Непрерывные массивы</a></h3>
<p>Начнем мы с <a href="game-loop.html" class="pattern">Game Loop</a>, который обрабатывает набор внутренних объектов. Эти объекты разделены на несколько областей&#8202;&mdash;&#8202;AI, физика и рендеринг&#8202;&mdash;&#8202;с использованием паттерна <a href="component.html" class="pattern">Component</a>. Вот класс объекта:</p>
<div class="codehilite"><pre> <span class="o">:::</span><span class="n">cpp</span>
 <span class="n">class</span> <span class="n">GameEntity</span>
 <span class="p">{</span>
 <span class="nl">public:</span>
   <span class="n">GameEntity</span><span class="p">(</span><span class="n">AIComponent</span><span class="o">*</span> <span class="n">ai</span><span class="p">,</span>
              <span class="n">PhysicsComponent</span><span class="o">*</span> <span class="n">physics</span><span class="p">,</span>
              <span class="n">RenderComponent</span><span class="o">*</span> <span class="n">render</span><span class="p">)</span>
   <span class="o">:</span> <span class="n">ai_</span><span class="p">(</span><span class="n">ai</span><span class="p">),</span> <span class="n">physics_</span><span class="p">(</span><span class="n">physics</span><span class="p">),</span> <span class="n">render_</span><span class="p">(</span><span class="n">render</span><span class="p">)</span>
   <span class="p">{}</span>

   <span class="n">AIComponent</span><span class="o">*</span>      <span class="n">ai</span><span class="p">()</span>      <span class="p">{</span> <span class="k">return</span> <span class="n">ai_</span><span class="p">;</span> <span class="p">}</span>
   <span class="n">PhysicsComponent</span><span class="o">*</span> <span class="n">physics</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">physics_</span><span class="p">;</span> <span class="p">}</span>
   <span class="n">RenderComponent</span><span class="o">*</span>  <span class="n">render</span><span class="p">()</span>  <span class="p">{</span> <span class="k">return</span> <span class="n">render_</span><span class="p">;</span> <span class="p">}</span>

 <span class="nl">private:</span>
   <span class="n">AIComponent</span><span class="o">*</span>      <span class="n">ai_</span><span class="p">;</span>
   <span class="n">PhysicsComponent</span><span class="o">*</span> <span class="n">physics_</span><span class="p">;</span>
   <span class="n">RenderComponent</span><span class="o">*</span>  <span class="n">render_</span><span class="p">;</span>
 <span class="p">};</span>
</pre></div>


<p>Каждый компонент имеет относительный малый набор аттрибутов (не больше пары векторов или одной матрицы) и метод <span name="update">update</span>, который их обновляет. Детали не так важны здесь, просто представьте что-то вроде следующего:</p>
<aside name="update">
<p>Метод update&#8202;&mdash;&#8202;это пример паттерна <a href="update-method.html" class="pattern">Update Method</a>.  Как и <code>render()</code>, просто с другим именем.</p>
</aside>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">AIComponent</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">update</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* Work with and modify state... */</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="c1">// Goals, mood, etc. ...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">PhysicsComponent</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">update</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* Work with and modify state... */</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="c1">// Rigid body, velocity, mass, etc. ...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">RenderComponent</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">render</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* Work with and modify state... */</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="c1">// Mesh, textures, shaders, etc. ...</span>
<span class="p">};</span>
</pre></div>


<p>Игра оперирует с большим массивом указателей на эти объекты. В каждой игровой итерации происходит следующее:</p>
<ol>
<li>
<p>Обновляем AI для всех объектов.</p>
</li>
<li>
<p>Применяем к ним физику.</p>
</li>
<li>
<p>И отображаем все объекты с помощью рендера.</p>
</li>
</ol>
<p>Большинство игр прямо так и делают:</p>
<div class="codehilite"><pre><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">gameOver</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Process AI.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numEntities</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">entities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ai</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Update physics.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numEntities</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">entities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">physics</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Draw to screen.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numEntities</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">entities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">render</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">render</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Other game loop machinery for timing...</span>
<span class="p">}</span>
</pre></div>


<p>До того как вы узнали про кэш процессора, все выглядело абсолютно невинно. Но сейчас у вас возникло подозрение, что то-то делается неправильно. Код не использует кэш по полной, вместо этого он просто убивает его. Смотрите, что происходит:</p>
<ol>
<li>
<p>Массив объектов&#8202;&mdash;&#8202;это <em>указатели</em> на объекты. Когда мы образаемся к объекту, мы достаем данные по указателю. Это кэш-промах.</p>
</li>
<li>
<p>Затем мы достаем компонент из указателя в объекте. Ещё кэш-промах.</p>
</li>
<li>
<p>Затем мы вызываем метод компонента.</p>
</li>
<li>
<p>И возвращаемся к шагу 1, чтобы повторить его для <em>каждого компонента каждого игрового объекта</em>.</p>
</li>
</ol>
<p>Страшная правда в том, что мы понятия не имеем как все эти объекты раскиданы по памяти. Этим распоряжается менеджер памяти. Если все время создавать и уничтожать объекты, то постепенно память заполнится данными в произвольном порядке.</p>
<p><span name="lines"></span></p>
<p><img src="images/data-locality-pointer-chasing.png" /></p>
<aside name="lines">
<p>Движку приходится бегать по этим стрелками каждый игровой ход, чтобы достать данные.</p>
</aside>
<p>Это было бы здорово, если бы мы хотели &#8220;объехать всю память за 80 дней&#8221;! Но нам нужно сделать цикл быстро и <span name="chase">бродить</span> по всей памяти не наш метод. Помните функцию <code>sleepFor500Cycles()</code>? Ну так вот&#8202;&mdash;&#8202;этот код использует её <em>постоянно</em>.</p>
<aside name="chase">
<p>Трата времени на разыменование указателей называется &#8220;блуждание по указателям&#8221;, и это не так весело как кажется.</p>
</aside>
<p>Придумаем что-нибудь получше. С первого взгляда ясно, что указатель на объект нам нужен только для доступа к <em>другому</em> указателю на его компонент. Сам <code>GameEntity</code>нам не интересен и дает нам ничего полезного. <em>Компоненты</em>&#8202;&mdash;&#8202;вот что нужно циклу.</p>
<p>Срубим под корень раскидистое дерево указателей на объекты! Нам нужно оформить по массиву на каждый тип компонента: один плоский массив для AI, один для физики и ещё один для рендера.</p>
<p>Как-то так:</p>
<p><span name="long-name"></span></p>
<div class="codehilite"><pre><span class="n">AIComponent</span><span class="o">*</span> <span class="n">aiComponents</span> <span class="o">=</span>
    <span class="k">new</span> <span class="n">AIComponent</span><span class="p">[</span><span class="n">MAX_ENTITIES</span><span class="p">];</span>
<span class="n">PhysicsComponent</span><span class="o">*</span> <span class="n">physicsComponents</span> <span class="o">=</span>
    <span class="k">new</span> <span class="n">PhysicsComponent</span><span class="p">[</span><span class="n">MAX_ENTITIES</span><span class="p">];</span>
<span class="n">RenderComponent</span><span class="o">*</span> <span class="n">renderComponents</span> <span class="o">=</span>
    <span class="k">new</span> <span class="n">RenderComponent</span><span class="p">[</span><span class="n">MAX_ENTITIES</span><span class="p">];</span>
</pre></div>


<aside name="long-name">
<p>Меньше всего в компонентах мне нравится длина самого слова &#8220;компонент&#8221;.</p>
</aside>
<p>Подчеркну, что это массив <em>компонентов</em>, а не <em>указателей на компонент</em>. Все данные прямо здесь, один за другим. Игровой цикл может оперировать прямо с ними:</p>
<p><span name="arrow"></span></p>
<div class="codehilite"><pre><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">gameOver</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Process AI.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numEntities</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">aiComponents</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">update</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Update physics.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numEntities</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">physicsComponents</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">update</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Draw to screen.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numEntities</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">renderComponents</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">render</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Other game loop machinery for timing...</span>
<span class="p">}</span>
</pre></div>


<aside name="arrow">
<p>Показатель того, что мы движемся в правильном направлении, это уменьшение количества &#8220;<code>-&gt;</code>&#8221; в коде. Если вам нужно улучшить компактность данных, ищите эти операторы и избавляйтесь от них.</p>
</aside>
<p>Итак, мы выбросили блуждание по указателям. Вместо метания по памяти, мы перебираем три непрерывных массива с прямыми данными.</p>
<p><img src="images/data-locality-component-arrays.png" /></p>
<p>Теперь плотный поток байтов загружается прямо в жадное горло процессора. По результатам тестов, это изменение ускоряет цикл в тридцать раз по сравнению с предыдущим вариантом.</p>
<p>Интересно, что мы почти не потеряли в инкапсуляции. Конечно, игровой цикл оперирует с компонентами напрямую, не доставая их из объектов. Но мы можем достать их заранее, чтобы убедиться что мы все делаем правильно. Более того, каждый компонент все ещё надежно инкапсулирован. Мы просто изменили способ доступа к ним.</p>
<p>Это не значит, что <code>GameEntity</code> больше не нужен. Мы оставим его, так как он все ещё держит указатели на свои компоненты. Они просто будут указывать на элементы наших массивов. Сам концепт &#8220;игрового объекта&#8221; может пригодиться в других частях кода. Важно, что для производительности игровой цикл обходит этот момент и использует данные напрямую.</p>
<h3><a href="#упаковка" name="упаковка">Упаковка</a></h3>
<p>Допустим, мы делаем систему частиц. Следуя совету из предыдущей секции, мы загрузили все частици в один большой непрерывный массив. Придумаем маленькую <span name="pool">систему частиц</span>:</p>
<aside name="pool">
<p>Класс <code>ParticleSystem</code> является примером паттерна <a href="object-pool.html" class="pattern">Object Pool</a> для одного типа объекта.</p>
</aside>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Particle</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">update</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* Gravity, etc. ... */</span> <span class="p">}</span>
  <span class="c1">// Position, velocity, etc. ...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ParticleSystem</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">update</span><span class="p">();</span>
<span class="nl">private:</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">MAX_PARTICLES</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">numParticles_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">Particle</span> <span class="n">particles_</span><span class="p">[</span><span class="n">MAX_PARTICLES</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>


<p>Его метод <code>update</code> выглядит следующим образом:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="n">ParticleSystem</span><span class="o">::</span><span class="n">update</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numParticles_</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">particles_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">update</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Но реальность показала, что нам не нужно обрабатывать <em>все</em> частицы каждый раз. Система содержит фиксированный набор частиц, но не все они активны на экране:</p>
<div class="codehilite"><pre><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numParticles_</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">particles_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">isActive</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="n">particles_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">update</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Мы дали <code>Particle</code> флажок, по которому определяем активна она или нет. В цикле мы <span name="branch">проверяем</span> его для каждой частицы. Флажок загружается в кэш вместе с целым объектом. И если частица <em>не активна</em>, мы просто переходим к следующей. Остальные аттрибуты частицы бесполезно загружаются в кэш.</p>
<p>Чем меньше активных частиц, тем больше частиц загружается в кэш вхолостую. Если массив большой и <em>большинство</em> частиц неактивно, то мы просто насилуем кэш без пользы.</p>
<p>Идея хранения объектов в непрерывном массиве не сильно помогает, так как набор частиц, с которым мы реально будем работать, не непрерывен. Массив замусорен неактивными частицами, которые нам надо пропускать, и мы возвращаемся к первоначальной проблеме.</p>
<aside name="branch">
<p>Смышленные программисты увидят здесь и другую проблему. Выполнение условия <code>if</code> для каждой частицы может привести к <em>сбою предсказания переходов</em> и <em>простою конвейера</em>.  В процессорах одна &#8220;инструкция&#8221; может занять несколько тактов. Чтобы процессор не простаивал, инструкции <em>распараллеливают</em>, чтобы следующая инструкция начала обрабатываться, не дожидаясь конца предыдущей.</p>
<p>Процессор пытается угадать, какая инструкция выполнится следующей. В линейном коде это просто, но условные переходы усложняют жизнь. Пока выполняется условие для <code>if</code>, какую часть кода брать следующей&#8202;&mdash;&#8202; <code>update()</code> или ничего не делать?</p>
<p>Для ответа на этот вопрос процессор использует <em>предсказание переходов</em>: он видит, по какому пути пошел в прошлый раз и предполагает, что пойдет по нему опять. И когда флажок постоянно переключается, это предсказание терпит сбой.</p>
<p>Когда происходит сбой, процессор выкидывает инструкции, которые он уже начал выполнять (<em>сброс конвейера</em>) и начинает заново. Влияние этого на производительность зависит от характеристик машины, но это та причина, по которой некоторые программисты пытаются избежать ветвлений в критических местах.</p>
</aside>
<p>Из названия секции, вы можете догадаться о решении этого вопроса. Вместо проверки <em>флага</em>, мы отсортируем по нему. Поместим все активные частицы в начало списка. Если мы будем знать, что эти частицы активны, проверка флага нам просто не нужна.</p>
<p>Мы можем хранить количество активных частиц. Тогда код превратится в следующую прекрасную штуку:</p>
<div class="codehilite"><pre><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numActive_</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">update</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p>Теперь мы не пропускаем <em>ни одного</em> лишнего байта. Каждый загружается в кэш для реальной работы с частицей.</p>
<p>Конечно, я не говорю, что вам нужно использовать быструю сортировку (quicksort) всего массива каждый раз. Это уничтожит все наши победы. Нам просто нужно <em>поддерживать</em> сортировку.</p>
<p>Предположим, что массив уже отсортирован&#8202;&mdash;&#8202;и это действительно для случая, когда все частицы неактивны. Сортировка <em>теряется</em>, когда частица переходит из неактивного состояния в активное и обратно. Это легко можно отследить. Как только частица становится активной, мы передвинем её на место первой <em>неактивной</em> частицы:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="n">ParticleSystem</span><span class="o">::</span><span class="n">activateParticle</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Shouldn&#39;t already be active!</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">numActive_</span><span class="p">);</span>

  <span class="c1">// Swap it with the first inactive particle</span>
  <span class="c1">// right after the active ones.</span>
  <span class="n">Particle</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">particles_</span><span class="p">[</span><span class="n">numActive_</span><span class="p">];</span>
  <span class="n">particles_</span><span class="p">[</span><span class="n">numActive_</span><span class="p">]</span> <span class="o">=</span> <span class="n">particles_</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
  <span class="n">particles_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>

  <span class="c1">// Now there&#39;s one more.</span>
  <span class="n">numActive_</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>При деактивации частицы, сделаем обратный ход:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="n">ParticleSystem</span><span class="o">::</span><span class="n">deactivateParticle</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Shouldn&#39;t already be inactive!</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">numActive_</span><span class="p">);</span>

  <span class="c1">// There&#39;s one fewer.</span>
  <span class="n">numActive_</span><span class="o">--</span><span class="p">;</span>

  <span class="c1">// Swap it with the last active particle</span>
  <span class="c1">// right before the inactive ones.</span>
  <span class="n">Particle</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">particles_</span><span class="p">[</span><span class="n">numActive_</span><span class="p">];</span>
  <span class="n">particles_</span><span class="p">[</span><span class="n">numActive_</span><span class="p">]</span> <span class="o">=</span> <span class="n">particles_</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
  <span class="n">particles_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Большинство (включая меня) выработали аллергию на копирование памяти. Перекидывание кучи байтов <em>выглядит</em> тяжелой операцией по сравнению с перемещением указателя. Но если вы прибавите к этому <em>разыменование</em> этого указателя, выяснится, что интуиция иногда обманывает. В <span name="profile">некоторых случаях</span>, дешевле перекинуть данные в памяти, если это поможет операциям с кэшем.</p>
<aside name="profile">
<p>Это тонкий намек на пользу <em>профайлера</em> при принятии решений подобного рода.</p>
</aside>
<p>Есть очевидное преимущество от хранения частиц <em>отсортированными</em> по активности: теперь не нужен флаг. Он заменяется позицией частицы в массиве и счетчиком <code>numActive_</code>. Из-за этого класс частицы становиться чуточку меньше, значит их больше поместится в кэш-линию, и все завертится ещё быстрее.</p>
<p>Ести и минусы, конечно. Мы потеряли немного объектно-ориентированности здесь. Класс <code>Particle</code> больше не управляет своим состоянием активности. Вы не сможете сделать у частицы метод <code>activate()</code>, так как она просто не знает свой индекс. Вместо этого придется иметь доступ к <em>системе частиц</em>.</p>
<p>В данном случае, я считаю нормальным, что <code>ParticleSystem</code> и <code>Particle</code> так жестко связаны между собой. Решая нашу главную задачу, пришлось вылезти за границы одного класса. И, скорее всего, именно система будет решать когда создавать частицы и когда их убивать.</p>
<h3><a href="#hot/cold-splitting" name="hot/cold-splitting">Hot/cold splitting</a></h3>
<p>OK, this is the last example of a simple technique for making your cache happier. Say we&#8217;ve got an AI component for some game entity. It has some state in it: the animation it&#8217;s currently playing, a goal position its heading towards, energy level, etc.&#8202;&mdash;&#8202;stuff it checks and tweaks every single frame. Something like:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">AIComponent</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">update</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">Animation</span><span class="o">*</span> <span class="n">animation_</span><span class="p">;</span>
  <span class="kt">double</span>     <span class="n">energy_</span><span class="p">;</span>
  <span class="n">Vector</span>     <span class="n">goalPos_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>But it also has some state for rarer eventualities. It stores some data describing what loot it drops when it has an unfortunate encounter with the noisy end of a shotgun. That drop data is only used once in the entity&#8217;s lifetime, right at its bitter end.</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">AIComponent</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">update</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="c1">// Previous fields...</span>
  <span class="n">LootType</span> <span class="n">drop_</span><span class="p">;</span>
  <span class="kt">int</span>      <span class="n">minDrops_</span><span class="p">;</span>
  <span class="kt">int</span>      <span class="n">maxDrops_</span><span class="p">;</span>
  <span class="kt">double</span>   <span class="n">chanceOfDrop_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>Assuming we followed the earlier patterns, when we update these AI components, we walk through a nice packed, contiguous array of data. But that data includes all of the loot drop information. That makes each component bigger, which reduces the number of them we can fit in a cache line. We get more cache misses because the total memory we walk over is larger. The loot data gets pulled into the cache for every component, every frame, even though we aren&#8217;t even touching it.</p>
<p>The solution for this is called &#8220;hot/cold splitting&#8221;. The idea is to break our data structure into two separate pieces. The first holds the &#8220;hot&#8221; data: the state we need to touch every frame. The other piece is the &#8220;cold&#8221; data: everything else that gets used less frequently.</p>
<p>The hot piece is the <em>main</em> AI component. It&#8217;s the one we need to use the most, so we don&#8217;t want to chase a pointer to find it. The cold component can be off to the side, but we still need to get to it, so we give the hot component a pointer to it, like so:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">AIComponent</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="c1">// Methods...</span>
<span class="nl">private:</span>
  <span class="n">Animation</span><span class="o">*</span>   <span class="n">animation_</span><span class="p">;</span>
  <span class="kt">double</span>       <span class="n">energy_</span><span class="p">;</span>
  <span class="n">Vector</span>       <span class="n">goalPos_</span><span class="p">;</span>

  <span class="n">LootDrop</span><span class="o">*</span>    <span class="n">loot_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">LootDrop</span>
<span class="p">{</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">AIComponent</span><span class="p">;</span>
  <span class="n">LootType</span> <span class="n">drop_</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">minDrops_</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">maxDrops_</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">chanceOfDrop_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>Now when we&#8217;re walking the AI components every frame, the only data that gets loaded into the cache is stuff we are actually processing (with the <span name="parallel">exception</span> of that one little pointer to the cold data).</p>
<aside name="parallel">
<p>We could conceivably ditch the pointer too by having parallel arrays for the hot and cold components. Then we can find the cold AI data for a component since both pieces will be at the same index in their respective arrays.</p>
</aside>
<p>You can see how this starts to get fuzzy, though. In my example here, it&#8217;s pretty obvious which data should be hot and cold, but it&#8217;s rarely so clear cut. What if you have fields that are used when an entity is in a certain mode but not in others? What if entities use a certain chunk of data only when they&#8217;re in certain parts of the level?</p>
<p>Doing this kind of optimization is somewhere between a black art and a rathole. It&#8217;s easy to get sucked in and spend endless time pushing data around to see what speed difference it makes. It will take practice to get a handle on where to spend your effort.</p>
<h2><a href="#design-decisions" name="design-decisions">Design Decisions</a></h2>
<p>This pattern is really about a mindset: it&#8217;s getting you to think about your data&#8217;s arrangement in memory as a key part of your game&#8217;s performance story. The actual concrete design space is wide open. You can let <span name="dod">data locality</span> affect your whole architecture, or maybe it&#8217;s just a localized pattern you apply to a few core data structures.</p>
<p>The biggest question you&#8217;ll need to answer is when and where you apply this pattern, but here are a couple of others that may come up.</p>
<aside name="dod">
<p>Noel Llopis&#8217; <a href="http://gamesfromwithin.com/data-oriented-design">famous article</a> that got a lot more people thinking about designing games around cache usage calls this &#8220;data-oriented design&#8221;.</p>
</aside>
<h3><a href="#how-do-you-handle-polymorphism?" name="how-do-you-handle-polymorphism?">How do you handle polymorphism?</a></h3>
<p>Up to this point, we&#8217;ve avoided subclassing and virtual methods. We assumed we have nice packed arrays of <em>homogenous</em> objects. That way, we know they&#8217;re all the exact same size. But polymorphism and dynamic dispatch are useful tools, too. How do we reconcile this?</p>
<ul>
<li>
<p><strong>Don&#8217;t:</strong></p>
<p>The <span name="type">simplest</span> answer is to just avoid subclassing, or at least avoid it in places where you&#8217;re optimizing for cache usage. Software engineer culture is drifting away from heavy use of inheritance anyway.</p>
<aside name="type">

<p>One way to keep much of the flexibility of polymorphism without using subclassing is through the <a href="type-object.html" class="pattern">Type Object</a> pattern.</p>
</aside>

<ul>
<li>
<p><em>It&#8217;s safe and easy.</em> You know exactly what class you&#8217;re dealing with and all objects are obviously the same size.</p>
</li>
<li>
<p><em>It&#8217;s faster.</em> Dynamic dispatch means looking up the method in the vtable and then traversing that pointer to get to the actual code. While the cost of this varies widely across different hardware, there is <span name="cpp"><em>some</em></span> cost to dynamic dispatch.</p>
</li>
</ul>
<aside name="cpp">

<p>As usual, the only absolute is that there are no absolutes. In most cases, a C++ compiler will require an indirection for a virtual method call. But in <em>some</em> cases, the compiler may be able to do <em>devirtualization</em> and statically call the right method if it knows what concrete type the receiver is. Devirtualization is more common in just-in-time compilers for languages like Java and JavaScript.</p>
</aside>

<ul>
<li><em>It&#8217;s inflexible.</em> Of course, the reason we use dynamic dispatch is because it gives us a powerful way to vary behavior between objects. If you want different entities in your game to have their own rendering styles, or their own special moves and attacks, virtual methods are a proven way to model that. Having to instead stuff all of that code into a single non-virtual method that does something like a big <code>switch</code> gets messy quickly.</li>
</ul>
</li>
<li>
<p><strong>Use separate arrays for each type:</strong></p>
<p>We use polymorphism so that we can invoke behavior on an object whose type we don&#8217;t know. In other words, we have a mixed bag of stuff and we want each object in there to do its own thing when we tell it to go.</p>
<p>But that just raises the question of why mix the bag to begin with? Instead, why not just maintain separate homogenous collections for each type?</p>
<ul>
<li>
<p><em>It keeps objects tightly packed.</em> Since each array only contains objects of one class, there&#8217;s no padding or other weirdness.</p>
</li>
<li>
<p><em>You can statically dispatch.</em> Once you&#8217;ve got objects partitioned by type, you don&#8217;t actually need polymorphism at all any more. You can use regular non-virtual method calls.</p>
</li>
<li>
<p><em>You have to keep track of a bunch of collections.</em> If you have a lot of different object types, the overhead and complexity of maintaining separate arrays for each can be a chore.</p>
</li>
<li>
<p><em>You have to be aware of every type</em>. Since you have to maintain separate collections for each type, you can&#8217;t be decoupled from the <em>set</em> of classes. Part of the magic of polymorphism is that it&#8217;s <em>open-ended</em>: code that works with an interface can be completely decoupled from the potentially large set of types that implement that interface.</p>
</li>
</ul>
</li>
<li>
<p><strong>Use a collection of pointers:</strong></p>
<p>If you weren&#8217;t worried about caching, this is the natural solution. Just have an array of pointers to some base class or interface type. All the polymorphism you could want, and objects can be whatever size they want.</p>
<ul>
<li>
<p><em>It&#8217;s flexible.</em> The code that consumes the collection can work with objects of any type as long as it supports the interface you care about. It&#8217;s completely open-ended.</p>
</li>
<li>
<p><em>It&#8217;s less cache-friendly.</em> Of course, the whole reason we&#8217;re discussing other options here is because this means cache-unfriendly pointer indirection. But, remember, if this code isn&#8217;t performance critical, that&#8217;s probably OK.</p>
</li>
</ul>
</li>
</ul>
<h3><a href="#how-are-game-entities-defined?" name="how-are-game-entities-defined?">How are game entities defined?</a></h3>
<p>If you use this pattern in tandem with the <a href="component.html" class="pattern">Component</a> pattern, you&#8217;ll have nice contiguous arrays for all of the components that make up your game entities. The game loop will be iterating over those directly, so the object for the game entity itself is less important, but it&#8217;s still useful in other parts of the codebase where you want to work with a single conceptual &#8220;entity&#8221;.</p>
<p>The question then is how should it be represented? How does it keep track of its components?</p>
<ul>
<li>
<p><strong>If game entities are classes with pointers to their components:</strong></p>
<p>This is what our first example looked like. It&#8217;s sort of the vanilla OOP solution. You&#8217;ve got a class for <code>GameEntity</code>, and it has pointers to the components it owns. Since they&#8217;re just pointers, it&#8217;s agnostic about where and how those components are actually organized in memory.</p>
<ul>
<li>
<p><em>You can store components in contiguous arrays.</em> Since the game entity doesn&#8217;t care where its components are, you can organize them in a nice packed array to optimize iterating over them.</p>
</li>
<li>
<p><em>Given an entity, you can easily get to its components.</em> They&#8217;re just a pointer indirection away.</p>
</li>
<li>
<p><em>Moving components in memory is hard.</em> When components get enabled or disabled, you may want to move them around in the array to keep the active ones up front and contiguous. If you move a component while the entity has a raw pointer to it, though, that pointer gets broken if you aren&#8217;t careful. You&#8217;ll have to make sure to update the entity&#8217;s pointer at the same time.</p>
</li>
</ul>
</li>
<li>
<p><strong>If game entities are classes with IDs for their components:</strong></p>
<p>The challenge with raw pointers to components is that it makes it harder to move them around in memory. You can address that by using something more abstract: an ID or index that can be used to <em>look up</em> a component.</p>
<p>The actual semantics of the ID and lookup process are up to you. It could be as simple as storing a unique ID in each component and walking the array, or more complex like a hash table that maps IDs to their current index in the component array.</p>
<ul>
<li>
<p><em>It&#8217;s more complex.</em> Your ID system doesn&#8217;t have to be rocket science, but it&#8217;s still more work than a basic pointer. You&#8217;ll have to implement and debug it, and there will be memory overhead for bookkeeping.</p>
</li>
<li>
<p><em>It&#8217;s slower</em>. It&#8217;s hard to beat traversing a raw pointer. There may be some actual searching or hashing involved to get from an entity to one of its components.</p>
</li>
<li>
<p><em>You&#8217;ll need access to the component &#8220;manager&#8221;.</em> The basic idea is that you have some abstract ID that identifies a component. You can use it to get a reference to the actual component object. But to do that, you need to hand that ID to something that can actually find the component. That will be the class that wraps your raw contiguous array of component objects.</p>
<p>With raw pointers, if you have a game entity, you can find its components. With this, you <span name="singleton">need</span> the game entity <em>and the component registry too</em>.</p>
<aside name="singleton">

<p>You may be thinking, &#8220;I&#8217;ll just make it a singleton! Problem solved!&#8221; Well, sort of. You might want to check out <a href="singleton.html">the chapter</a> on those first.</p>
</aside>

</li>
</ul>
</li>
<li>
<p><strong>If the game entity is <em>itself</em> just an ID:</strong></p>
<p>This is a newer style that some game engines use. Once you&#8217;ve moved all of your entity&#8217;s behavior and state out of the main class and into components, what&#8217;s left? It turns out, not much. The only thing an entity does is bind a set of components together. It exists just to say <em>this</em> AI component and <em>this</em> physics component and <em>this</em> render component define one living entity in the world.</p>
<p>That&#8217;s important because components interact. The render component needs to know where the entity is, which may be a property of the physics component. The AI component wants to move the entity, so it needs to apply a force to the physics component. Each component needs a way to get the other sibling components of the entity it&#8217;s a part of.</p>
<p>Some smart people realized all you need for that is an ID. Instead of the entity knowing its components, the components know their entity. Each component knows the ID of the entity that owns it. When the AI component needs the physics component for its entity, it just asks for the physics component with the same entity ID that it holds.</p>
<p>Your entity <em>classes</em> disappear entirely, replaced by a glorified wrapper around a number.</p>
<ul>
<li>
<p><em>Entities are tiny.</em> When you want to pass around a reference to a game entity, it&#8217;s just a single value.</p>
</li>
<li>
<p><em>Entities are empty.</em> Of course, the downside of moving everything out of entities is that you <em>have</em> to move everything out of entities. You no longer have a place to put non-component-specific state or behavior. This style
doubles down on the component pattern.</p>
</li>
<li>
<p><em>You don&#8217;t have to manage their lifetime.</em> Since entities are just dumb value types, they don&#8217;t need to be explicitly allocated and freed. An entity implicitly &#8220;dies&#8221; when all of its components are destroyed.</p>
</li>
<li>
<p><em>Looking up a component for an entity may be slow.</em> This is the same problem as the previous answer, but in the opposite direction. To find a component for some entity, you have to map an ID to an object. That process may be costly.</p>
<p>This time, though, it <em>is</em> performance critical. Components often interact with their siblings during update, so you will need to find components frequently. One solution is to make the &#8220;ID&#8221; of an entity just the index of the component in its array.</p>
<p>If every entity has the same set of components, then your component arrays are completely parallel. The component in slot three of the AI component array will be for the same entity that the physics component in slot three of <em>its</em> array is associated with.</p>
<p>Keep in mind, though, that this <em>forces</em> you to keep those arrays in parallel. That&#8217;s hard if you want to start sorting or packing them by different criteria. You may have some entities with disabled physics and others that are invisible. There&#8217;s no way to sort the physics and render component arrays optimally for both cases if they have to stay in sync with each other.</p>
</li>
</ul>
</li>
</ul>
<h2><a href="#see-also" name="see-also">See Also</a></h2>
<ul>
<li>
<p>Much of this chapter revolves around the <a href="component.html" class="pattern">Component</a> pattern, and those are definitely one of the most common data structures that get optimized for cache usage. In fact, using the component pattern makes this optimization easier. Since entities are updated one &#8220;domain&#8221; (AI, physics, etc.) at a time, splitting them out into components lets you slice a bunch of entities into just the right pieces to be cache-friendly.</p>
<p>But that doesn&#8217;t mean you can <em>only</em> use this pattern with components! Any time you have performance critical code that touches a lot of data, it&#8217;s important to think about locality.</p>
</li>
<li>
<p>Tony Albrecht&#8217;s <a href="http://research.scee.net/files/presentations/gcapaustralia09/Pitfalls_of_Object_Oriented_Programming_GCAP_09.pdf" class="pdf">&#8220;Pitfalls of Object-Oriented Programming&#8221;</a> is probably the most widely-read introduction to designing your game&#8217;s data structures for cache-friendliness. It made a lot more people (including me!) aware of how big a deal this is for performance.</p>
</li>
<li>
<p>Around the same time, Noel Llopis wrote a <a href="http://gamesfromwithin.com/data-oriented-design">very influential blog post</a> on the same topic.</p>
</li>
<li>
<p>This pattern almost invariably takes advantage of a contiguous array of homogenous objects. Over time, you&#8217;ll very likely be adding and removing objects from that array. The <a href="object-pool.html" class="pattern">Object Pool</a> pattern is about exactly that.</p>
</li>
<li>
<p>The <a href="http://gamadu.com/artemis/">Artemis</a> game engine is one of the first and better-known frameworks that uses simple IDs for game entities.</p>
</li>
</ul>
<nav>
  <span class="prev">&larr; <a href="optimization-patterns.html">Предыдущая глава</a></span>
  <span class="next"><a href="dirty-flag.html">Next Chapter</a> &rarr;</span>
  <span class="toc">&equiv; <a href="/">Table of Contents</a></span>
</nav>
</div>
</div>
<footer>&copy; 2009-2014 Robert Nystrom</footer>
</body>
</html>
